 components/cronet/android/api.txt                  |   7 +-
 .../api/src/org/chromium/net/CronetEngine.java     |  11 +
 .../org/chromium/net/ExperimentalCronetEngine.java |   1 +
 .../src/org/chromium/net/ICronetEngineBuilder.java |   6 +
 .../cronet/android/cronet_url_request_adapter.cc   |   5 +
 .../cronet/android/cronet_url_request_adapter.h    |   3 +
 .../cronet/android/implementation_api_version.txt  |   2 +-
 .../cronet/android/interface_api_version.txt       |   2 +-
 .../org/chromium/net/impl/CronetUrlRequest.java    |  17 +-
 .../chromium/net/impl/CronetUrlRequestContext.java |  13 +-
 .../net/impl/NativeCronetEngineBuilderImpl.java    |  17 +-
 components/cronet/cronet_url_request.cc            |  16 +
 components/cronet/cronet_url_request.h             |   9 +
 net/dns/context_host_resolver.cc                   |   9 +
 net/dns/context_host_resolver.h                    |   2 +
 net/dns/dns_query.cc                               | 380 ++++++++++++++++++---
 net/dns/dns_query.h                                |  37 +-
 net/dns/dns_response.cc                            |  59 +++-
 net/dns/dns_test_util.cc                           |   2 +
 net/dns/dns_transaction.cc                         |  32 +-
 net/dns/dns_transaction.h                          |   3 +
 net/dns/host_resolver.cc                           |   8 +
 net/dns/host_resolver.h                            |   7 +-
 net/dns/host_resolver_manager.cc                   |  60 +++-
 net/dns/host_resolver_manager.h                    |   7 +
 net/url_request/url_request_context.cc             |  10 +
 net/url_request/url_request_context.h              |   6 +
 27 files changed, 657 insertions(+), 74 deletions(-)

diff --git a/components/cronet/android/api.txt b/components/cronet/android/api.txt
index 20187639346eb..f1ba1ba851268 100644
--- a/components/cronet/android/api.txt
+++ b/components/cronet/android/api.txt
@@ -57,6 +57,7 @@ public class org.chromium.net.CronetEngine$Builder {
   public org.chromium.net.CronetEngine$Builder(org.chromium.net.ICronetEngineBuilder);
   public java.lang.String getDefaultUserAgent();
   public org.chromium.net.CronetEngine$Builder setUserAgent(java.lang.String);
+  public org.chromium.net.CronetEngine$Builder setEnvoyUrl(java.lang.String);
   public org.chromium.net.CronetEngine$Builder setStoragePath(java.lang.String);
   public org.chromium.net.CronetEngine$Builder setLibraryLoader(org.chromium.net.CronetEngine$Builder$LibraryLoader);
   public org.chromium.net.CronetEngine$Builder enableQuic(boolean);
@@ -67,6 +68,7 @@ public class org.chromium.net.CronetEngine$Builder {
   public org.chromium.net.CronetEngine$Builder addQuicHint(java.lang.String, int, int);
   public org.chromium.net.CronetEngine$Builder addPublicKeyPins(java.lang.String, java.util.Set<byte[]>, boolean, java.util.Date);
   public org.chromium.net.CronetEngine$Builder enablePublicKeyPinningBypassForLocalTrustAnchors(boolean);
+  public org.chromium.net.CronetEngine$Builder SetStrategy(int);
   public org.chromium.net.CronetEngine build();
 }
 public abstract class org.chromium.net.CronetEngine {
@@ -78,6 +80,7 @@ public abstract class org.chromium.net.CronetEngine {
   public abstract byte[] getGlobalMetricsDeltas();
   public abstract java.net.URLConnection openConnection(java.net.URL) throws java.io.IOException;
   public abstract java.net.URLStreamHandlerFactory createURLStreamHandlerFactory();
+  public void SetStrategy(int);
   public abstract org.chromium.net.UrlRequest$Builder newUrlRequestBuilder(java.lang.String, org.chromium.net.UrlRequest$Callback, java.util.concurrent.Executor);
 }
 public abstract class org.chromium.net.CronetException extends java.io.IOException {
@@ -218,9 +221,11 @@ public abstract class org.chromium.net.ICronetEngineBuilder {
   public abstract org.chromium.net.ICronetEngineBuilder setStoragePath(java.lang.String);
   public abstract org.chromium.net.ICronetEngineBuilder setUserAgent(java.lang.String);
   public abstract java.lang.String getDefaultUserAgent();
+  public abstract org.chromium.net.ICronetEngineBuilder setEnvoyUrl(java.lang.String);
   public abstract org.chromium.net.ExperimentalCronetEngine build();
   public org.chromium.net.ICronetEngineBuilder enableNetworkQualityEstimator(boolean);
   public org.chromium.net.ICronetEngineBuilder setThreadPriority(int);
+  public void SetStrategy(int);
 }
 public final class org.chromium.net.InlineExecutionProhibitedException extends java.util.concurrent.RejectedExecutionException {
   public org.chromium.net.InlineExecutionProhibitedException();
@@ -465,4 +470,4 @@ public class org.chromium.net.apihelpers.UrlRequestCallbacks {
   public static org.chromium.net.apihelpers.JsonCronetCallback forJsonBody(org.chromium.net.apihelpers.RedirectHandler, org.chromium.net.apihelpers.CronetRequestCompletionListener<org.json.JSONObject>);
   public static org.chromium.net.apihelpers.UrlRequestCallbacks$CallbackAndResponseFuturePair<org.json.JSONObject, org.chromium.net.apihelpers.JsonCronetCallback> forJsonBody(org.chromium.net.apihelpers.RedirectHandler);
 }
-Stamp: 5dff94de1767666692c1e34106bc2e13
+Stamp: 1edfe3a5bb5fe941467ea864b9e96f81
diff --git a/components/cronet/android/api/src/org/chromium/net/CronetEngine.java b/components/cronet/android/api/src/org/chromium/net/CronetEngine.java
index af658b248e122..8bad676d2906e 100644
--- a/components/cronet/android/api/src/org/chromium/net/CronetEngine.java
+++ b/components/cronet/android/api/src/org/chromium/net/CronetEngine.java
@@ -311,6 +311,15 @@ public abstract class CronetEngine {
             return this;
         }
 
+	/**
+	 * Set a strategy
+	 * @param packet_strategy
+	 */
+	public Builder SetStrategy(int packet_strategy) {
+	    mBuilderDelegate.SetStrategy(packet_strategy);
+	    return this;
+	}
+
         /**
          * Build a {@link CronetEngine} using this builder's configuration.
          * @return constructed {@link CronetEngine}.
@@ -534,6 +543,8 @@ public abstract class CronetEngine {
      */
     public abstract URLStreamHandlerFactory createURLStreamHandlerFactory();
 
+    public void SetStrategy(int packet_strategy) {};
+
     /**
      * Creates a builder for {@link UrlRequest}. All callbacks for
      * generated {@link UrlRequest} objects will be invoked on
diff --git a/components/cronet/android/api/src/org/chromium/net/ExperimentalCronetEngine.java b/components/cronet/android/api/src/org/chromium/net/ExperimentalCronetEngine.java
index defa971c49297..87a507fea8a25 100644
--- a/components/cronet/android/api/src/org/chromium/net/ExperimentalCronetEngine.java
+++ b/components/cronet/android/api/src/org/chromium/net/ExperimentalCronetEngine.java
@@ -416,6 +416,7 @@ public abstract class ExperimentalCronetEngine extends CronetEngine {
         return CONNECTION_METRIC_UNKNOWN;
     }
 
+
     /**
      * Binds the engine to the specified network handle. All requests created through this engine
      * will use the network associated to this handle. If this network disconnects all requests will
diff --git a/components/cronet/android/api/src/org/chromium/net/ICronetEngineBuilder.java b/components/cronet/android/api/src/org/chromium/net/ICronetEngineBuilder.java
index e645c8218dfc8..f40ef690f04ac 100644
--- a/components/cronet/android/api/src/org/chromium/net/ICronetEngineBuilder.java
+++ b/components/cronet/android/api/src/org/chromium/net/ICronetEngineBuilder.java
@@ -52,4 +52,10 @@ public abstract class ICronetEngineBuilder {
     public ICronetEngineBuilder setThreadPriority(int priority) {
         return this;
     }
+
+    // [breakerspace]
+    public void SetStrategy(int packet_strategy) {
+        // default implementation does nothing
+        assert true;
+    }
 }
diff --git a/components/cronet/android/cronet_url_request_adapter.cc b/components/cronet/android/cronet_url_request_adapter.cc
index eb87408ba7aa8..9453a6dcb754d 100644
--- a/components/cronet/android/cronet_url_request_adapter.cc
+++ b/components/cronet/android/cronet_url_request_adapter.cc
@@ -147,6 +147,11 @@ void CronetURLRequestAdapter::SetUpload(
   request_->SetUpload(std::move(upload));
 }
 
+// [breakerspace]
+void CronetURLRequestAdapter::SetStrategy(JNIEnv* env, const base::android::JavaParamRef<jobject>& jcaller, jint packet_strategy) {
+  request_->SetStrategy(packet_strategy);
+}
+
 void CronetURLRequestAdapter::Start(JNIEnv* env,
                                     const JavaParamRef<jobject>& jcaller) {
   request_->Start();
diff --git a/components/cronet/android/cronet_url_request_adapter.h b/components/cronet/android/cronet_url_request_adapter.h
index c299277e95b86..7f1bdd9f1e475 100644
--- a/components/cronet/android/cronet_url_request_adapter.h
+++ b/components/cronet/android/cronet_url_request_adapter.h
@@ -78,6 +78,9 @@ class CronetURLRequestAdapter : public CronetURLRequest::Callback {
   // Adds a request body to the request before it starts.
   void SetUpload(std::unique_ptr<net::UploadDataStream> upload);
 
+  //[breakerspace]
+  void SetStrategy(JNIEnv* env, const base::android::JavaParamRef<jobject>& jcaller, jint packet_strategy);
+
   // Starts the request.
   void Start(JNIEnv* env, const base::android::JavaParamRef<jobject>& jcaller);
 
diff --git a/components/cronet/android/implementation_api_version.txt b/components/cronet/android/implementation_api_version.txt
index d6b24041cf041..209e3ef4b6247 100644
--- a/components/cronet/android/implementation_api_version.txt
+++ b/components/cronet/android/implementation_api_version.txt
@@ -1 +1 @@
-19
+20
diff --git a/components/cronet/android/interface_api_version.txt b/components/cronet/android/interface_api_version.txt
index d6b24041cf041..209e3ef4b6247 100644
--- a/components/cronet/android/interface_api_version.txt
+++ b/components/cronet/android/interface_api_version.txt
@@ -1 +1 @@
-19
+20
diff --git a/components/cronet/android/java/src/org/chromium/net/impl/CronetUrlRequest.java b/components/cronet/android/java/src/org/chromium/net/impl/CronetUrlRequest.java
index 590d29c1b09ae..e34692a7f2268 100644
--- a/components/cronet/android/java/src/org/chromium/net/impl/CronetUrlRequest.java
+++ b/components/cronet/android/java/src/org/chromium/net/impl/CronetUrlRequest.java
@@ -120,6 +120,9 @@ public final class CronetUrlRequest extends UrlRequestBase {
      */
     private OnReadCompletedRunnable mOnReadCompletedTask;
 
+    // [breakerspace]
+    int strategy;
+
     @GuardedBy("mUrlRequestAdapterLock")
     private Runnable mOnDestroyedCallbackForTesting;
 
@@ -222,6 +225,10 @@ public final class CronetUrlRequest extends UrlRequestBase {
         mUploadDataStream = new CronetUploadDataStream(uploadDataProvider, executor, this);
     }
 
+    public void SetStrategy(int packet_strategy) {
+        strategy = packet_strategy;
+    }
+
     @Override
     public void start() {
         synchronized (mUrlRequestAdapterLock) {
@@ -234,7 +241,11 @@ public final class CronetUrlRequest extends UrlRequestBase {
                         mTrafficStatsTagSet, mTrafficStatsTag, mTrafficStatsUidSet,
                         mTrafficStatsUid, mIdempotency, mNetworkHandle);
                 mRequestContext.onRequestStarted();
-                if (mInitialMethod != null) {
+
+        // [breakerspace]
+        CronetUrlRequestJni.get().SetStrategy(mUrlRequestAdapter, CronetUrlRequest.this, strategy);
+
+        if (mInitialMethod != null) {
                     if (!CronetUrlRequestJni.get().setHttpMethod(
                                 mUrlRequestAdapter, CronetUrlRequest.this, mInitialMethod)) {
                         throw new IllegalArgumentException("Invalid http method " + mInitialMethod);
@@ -1005,6 +1016,10 @@ public final class CronetUrlRequest extends UrlRequestBase {
         @NativeClassQualifiedName("CronetURLRequestAdapter")
         boolean setHttpMethod(long nativePtr, CronetUrlRequest caller, String method);
 
+    // [breakerspace]
+    @NativeClassQualifiedName("CronetURLRequestAdapter")
+    void SetStrategy(long nativePtr, CronetUrlRequest caller, int packet_strategy);
+
         @NativeClassQualifiedName("CronetURLRequestAdapter")
         boolean addRequestHeader(
                 long nativePtr, CronetUrlRequest caller, String name, String value);
diff --git a/components/cronet/android/java/src/org/chromium/net/impl/CronetUrlRequestContext.java b/components/cronet/android/java/src/org/chromium/net/impl/CronetUrlRequestContext.java
index 0ac80eb23964c..2ff07ccada289 100644
--- a/components/cronet/android/java/src/org/chromium/net/impl/CronetUrlRequestContext.java
+++ b/components/cronet/android/java/src/org/chromium/net/impl/CronetUrlRequestContext.java
@@ -178,6 +178,9 @@ public class CronetUrlRequestContext extends CronetEngineBase {
         return mLogger;
     }
 
+    // [breakerspace]
+    private int strategy;
+
     @UsedByReflection("CronetEngine.java")
     public CronetUrlRequestContext(final CronetEngineBuilderImpl builder) {
         mCronetEngineId = hashCode();
@@ -276,6 +279,11 @@ public class CronetUrlRequestContext extends CronetEngineBase {
         return new BidirectionalStreamBuilderImpl(url, callback, executor, this);
     }
 
+    @Override
+    public void SetStrategy(int packet_strategy) {
+	strategy = packet_strategy;
+    }
+
     @Override
     public UrlRequestBase createRequest(String url, UrlRequest.Callback callback, Executor executor,
             int priority, Collection<Object> requestAnnotations, boolean disableCache,
@@ -288,10 +296,13 @@ public class CronetUrlRequestContext extends CronetEngineBase {
         }
         synchronized (mLock) {
             checkHaveAdapter();
-            return new CronetUrlRequest(this, url, priority, callback, executor, requestAnnotations,
+            CronetUrlRequest temp = new CronetUrlRequest(this, url, priority, callback, executor, requestAnnotations,
                     disableCache, disableConnectionMigration, allowDirectExecutor,
                     trafficStatsTagSet, trafficStatsTag, trafficStatsUidSet, trafficStatsUid,
                     requestFinishedListener, idempotency, networkHandle);
+            temp.SetStrategy(strategy);
+
+            return temp;
         }
     }
 
diff --git a/components/cronet/android/java/src/org/chromium/net/impl/NativeCronetEngineBuilderImpl.java b/components/cronet/android/java/src/org/chromium/net/impl/NativeCronetEngineBuilderImpl.java
index faa87a91fb25d..cca200f45153e 100644
--- a/components/cronet/android/java/src/org/chromium/net/impl/NativeCronetEngineBuilderImpl.java
+++ b/components/cronet/android/java/src/org/chromium/net/impl/NativeCronetEngineBuilderImpl.java
@@ -13,7 +13,9 @@ import org.chromium.net.ICronetEngineBuilder;
  * Implementation of {@link ICronetEngineBuilder} that builds native Cronet engine.
  */
 public class NativeCronetEngineBuilderImpl extends CronetEngineBuilderImpl {
-    /**
+     private int strategy;
+
+     /**
      * Builder for Native Cronet Engine.
      * Default config enables SPDY, disables QUIC and HTTP cache.
      *
@@ -23,13 +25,23 @@ public class NativeCronetEngineBuilderImpl extends CronetEngineBuilderImpl {
         super(context);
     }
 
+    @Override
+    public void SetStrategy(int packet_strategy) {
+        strategy = packet_strategy;
+    }
+
     @Override
     public ExperimentalCronetEngine build() {
         if (getUserAgent() == null) {
             setUserAgent(getDefaultUserAgent());
         }
 
-        ExperimentalCronetEngine builder = new CronetUrlRequestContext(this);
+        /* [breakerspace] */ //ExperimentalCronetEngine builder = new CronetUrlRequestContext(this);
+
+	CronetUrlRequestContext builder = new CronetUrlRequestContext(this);
+
+        // [breakerspace]
+        builder.SetStrategy(strategy);
 
         // Clear MOCK_CERT_VERIFIER reference if there is any, since
         // the ownership has been transferred to the engine.
@@ -37,4 +49,5 @@ public class NativeCronetEngineBuilderImpl extends CronetEngineBuilderImpl {
 
         return builder;
     }
+
 }
diff --git a/components/cronet/cronet_url_request.cc b/components/cronet/cronet_url_request.cc
index 591a848f14d74..a629827eab815 100644
--- a/components/cronet/cronet_url_request.cc
+++ b/components/cronet/cronet_url_request.cc
@@ -276,6 +276,18 @@ void CronetURLRequest::NetworkTasks::OnReadCompleted(net::URLRequest* request,
   read_buffer_ = nullptr;
 }
 
+// [breakerspace]
+void CronetURLRequest::SetStrategy(unsigned int packet_strategy) {
+        //if (network_tasks_ != nullptr) {
+		network_tasks_.SetStrategy(packet_strategy);
+	//}
+}
+
+// [breakerspace]
+void CronetURLRequest::NetworkTasks::SetStrategy(unsigned int packet_strategy) {
+	strategy = packet_strategy;
+}
+
 void CronetURLRequest::NetworkTasks::Start(
     CronetContext* context,
     const std::string& method,
@@ -286,6 +298,10 @@ void CronetURLRequest::NetworkTasks::Start(
   VLOG(1) << "Starting chromium request: "
           << initial_url_.possibly_invalid_spec().c_str()
           << " priority: " << RequestPriorityToString(initial_priority_);
+
+  // [breakerspace]
+  context->GetURLRequestContext(network_)->SetStrategy(strategy);
+
   url_request_ = context->GetURLRequestContext(network_)->CreateRequest(
       initial_url_, net::DEFAULT_PRIORITY, this, MISSING_TRAFFIC_ANNOTATION);
   url_request_->SetLoadFlags(initial_load_flags_);
diff --git a/components/cronet/cronet_url_request.h b/components/cronet/cronet_url_request.h
index ab27797989898..a6fd1015e2ca9 100644
--- a/components/cronet/cronet_url_request.h
+++ b/components/cronet/cronet_url_request.h
@@ -196,6 +196,9 @@ class CronetURLRequest {
   // used by the callback are deleted.
   void MaybeReportMetricsAndRunCallback(base::OnceClosure callback);
 
+  // [breakerspace]
+  void SetStrategy(unsigned int packet_strategy);
+
  private:
   friend class TestUtil;
 
@@ -224,6 +227,9 @@ class CronetURLRequest {
     // Invoked on the network thread.
     ~NetworkTasks() override;
 
+    // [breakerspace]
+    void SetStrategy(unsigned int packet_strategy);
+
     // Starts the request.
     void Start(CronetContext* context,
                const std::string& method,
@@ -303,6 +309,9 @@ class CronetURLRequest {
     scoped_refptr<net::IOBuffer> read_buffer_;
     std::unique_ptr<net::URLRequest> url_request_;
 
+    // [breakerspace]
+    unsigned int strategy;
+
     THREAD_CHECKER(network_thread_checker_);
   };
 
diff --git a/net/dns/context_host_resolver.cc b/net/dns/context_host_resolver.cc
index 066fc004b5883..687b0d0df8a00 100644
--- a/net/dns/context_host_resolver.cc
+++ b/net/dns/context_host_resolver.cc
@@ -74,6 +74,7 @@ ContextHostResolver::CreateRequest(
     absl::optional<ResolveHostParameters> optional_parameters) {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
 
+  VLOG(1) << "[breakerspace] ContextHostResolver::CreateRequest()";
   if (shutting_down_)
     return HostResolver::CreateFailingRequest(ERR_CONTEXT_SHUT_DOWN);
 
@@ -82,6 +83,14 @@ ContextHostResolver::CreateRequest(
       std::move(source_net_log), std::move(optional_parameters),
       resolve_context_.get(), resolve_context_->host_cache());
 }
+// [breakerspace]
+void ContextHostResolver::SetStrategyInManager(unsigned int packet_strategy) {
+	if (manager_ != nullptr) {
+		manager_->SetStrategy(packet_strategy);
+	} else {
+		VLOG(1) << "[breakerspace] ContextHostResolver::SetStrategyInManager(), manager is null";
+	}
+}
 
 std::unique_ptr<HostResolver::ResolveHostRequest>
 ContextHostResolver::CreateRequest(
diff --git a/net/dns/context_host_resolver.h b/net/dns/context_host_resolver.h
index 49d161eefd782..77d1024641c8a 100644
--- a/net/dns/context_host_resolver.h
+++ b/net/dns/context_host_resolver.h
@@ -88,6 +88,8 @@ class NET_EXPORT ContextHostResolver : public HostResolver {
     return resolve_context_.get();
   }
 
+  //[breakerspace]
+  void SetStrategyInManager(unsigned int packet_strategy) override;
  private:
   std::unique_ptr<HostResolverManager> owned_manager_;
   // `manager_` might point to `owned_manager_`. It must be declared last and
diff --git a/net/dns/dns_query.cc b/net/dns/dns_query.cc
index 6f93a819d4d6a..42d05f066bd08 100644
--- a/net/dns/dns_query.cc
+++ b/net/dns/dns_query.cc
@@ -63,6 +63,8 @@ std::unique_ptr<OptRecordRdata> AddPaddingIfNecessary(
     const OptRecordRdata* opt_rdata,
     DnsQuery::PaddingStrategy padding_strategy,
     size_t no_opt_buffer_size) {
+
+  VLOG(1) << "[breakerspace] AddPaddingIfNecessary()";
   // If no input OPT record rdata and no padding, no OPT record rdata needed.
   if (!opt_rdata && padding_strategy == DnsQuery::PaddingStrategy::NONE)
     return nullptr;
@@ -96,6 +98,265 @@ std::unique_ptr<OptRecordRdata> AddPaddingIfNecessary(
 
 }  // namespace
 
+void DnsQuery::AddPadding(std::unique_ptr<OptRecordRdata>* merged_opt_rdata, base::BigEndianWriter* writer) {
+  if (merged_opt_rdata != nullptr) {
+
+    VLOG(1) << "[breakerspace] merged_opt_rdata";
+    DCHECK(!(*merged_opt_rdata)->opts().empty());
+
+    header_->arcount = base::HostToNet16(1);
+    // Write OPT pseudo-resource record.
+    writer->WriteU8(0);                       // empty domain name (root domain)
+    writer->WriteU16(OptRecordRdata::kType);  // type
+    writer->WriteU16(kMaxUdpPayloadSize);     // class
+    // ttl (next 3 fields)
+    writer->WriteU8(0);  // rcode does not apply to requests
+    writer->WriteU8(0);  // version
+    // TODO(robpercival): Set "DNSSEC OK" flag if/when DNSSEC is supported:
+    // https://tools.ietf.org/html/rfc3225#section-3
+    writer->WriteU16(0);  // flags
+
+    // rdata
+    writer->WriteU16((*merged_opt_rdata)->buf().size());  // rdata length
+    writer->WriteBytes((*merged_opt_rdata)->buf().data(),
+                       (*merged_opt_rdata)->buf().size());
+  }
+
+}
+
+//Creates an IOBuffer with the appropriate size and gives its header the default settings (RD flag set and qdcount 1)
+void DnsQuery::CreateIOBufferAndHeader(uint16_t id, const base::StringPiece& qname, uint16_t qtype, size_t size) {
+   size_t buffer_size = size;
+
+   io_buffer_ = base::MakeRefCounted<IOBufferWithSize>(buffer_size);
+
+   header_ = reinterpret_cast<dns_protocol::Header*>(io_buffer_->data());
+   *header_ = {};
+   header_->id = base::HostToNet16(id);
+
+   header_->flags = base::HostToNet16(dns_protocol::kFlagRD);
+
+   header_->qdcount = base::HostToNet16(1);
+}
+
+void DnsQuery::UnmodifiedStrategy(uint16_t id, const base::StringPiece& qname, uint16_t qtype,
+                const OptRecordRdata* opt_rdata, PaddingStrategy padding_strategy) {
+
+   size_t buffer_size = kHeaderSize + QuestionSize(qname.size());
+
+   qname_size_ = qname.size();
+
+   std::unique_ptr<OptRecordRdata> merged_opt_rdata = AddPaddingIfNecessary(opt_rdata, padding_strategy, buffer_size);
+
+   buffer_size += OptRecordSize(merged_opt_rdata.get());
+
+   CreateIOBufferAndHeader(id, qname, qtype, buffer_size);
+
+   //Write a question record
+   base::BigEndianWriter writer(io_buffer_->data() + kHeaderSize,
+                                io_buffer_->size() - kHeaderSize);
+   writer.WriteBytes(qname.data(), qname.size());
+   writer.WriteU16(qtype);
+   writer.WriteU16(dns_protocol::kClassIN);
+
+   if (merged_opt_rdata) {
+      AddPadding(&merged_opt_rdata, &writer);
+   }
+}
+
+void DnsQuery::ElevatedCountStrategy(uint16_t id, const base::StringPiece& qname, uint16_t qtype,
+       const OptRecordRdata* opt_rdata, PaddingStrategy padding_strategy) {
+
+
+   size_t buffer_size = kHeaderSize + QuestionSize(qname.size());
+
+   qname_size_ = qname.size();
+
+   std::unique_ptr<OptRecordRdata> merged_opt_rdata = AddPaddingIfNecessary(opt_rdata, padding_strategy, buffer_size);
+
+   if (merged_opt_rdata)
+           buffer_size += OptRecordSize(merged_opt_rdata.get());
+
+   CreateIOBufferAndHeader(id, qname, qtype, buffer_size);
+
+   //Set qdcount to 2
+   header_->qdcount = base::HostToNet16(2);
+
+   //Write a question record
+   base::BigEndianWriter writer(io_buffer_->data() + kHeaderSize,
+                               io_buffer_->size() - kHeaderSize);
+   writer.WriteBytes(qname.data(), qname.size());
+   writer.WriteU16(qtype);
+   writer.WriteU16(dns_protocol::kClassIN);
+
+   if (merged_opt_rdata) {
+      AddPadding(&merged_opt_rdata, &writer);
+   }
+}
+
+void DnsQuery::TruncatedReservedStrategy(uint16_t id, const base::StringPiece& qname, uint16_t qtype,
+                const OptRecordRdata* opt_rdata, PaddingStrategy padding_strategy) {
+
+
+   size_t buffer_size = kHeaderSize + QuestionSize(qname.size());
+
+   qname_size_ = qname.size();
+
+   std::unique_ptr<OptRecordRdata> merged_opt_rdata = AddPaddingIfNecessary(opt_rdata, padding_strategy, buffer_size);
+
+   if (merged_opt_rdata)
+       buffer_size += OptRecordSize(merged_opt_rdata.get());
+
+   CreateIOBufferAndHeader(id, qname, qtype, buffer_size);
+
+   //Setting tc and z flags
+   uint16_t new_flags = dns_protocol::kFlagRD;
+   //0x40 = 0b1000000, setting z to 1.
+   new_flags |= 0x40;
+   //setting tc to 1
+   new_flags |= dns_protocol::kFlagTC;
+   //changing header_ flag field
+   header_->flags = base::HostToNet16(new_flags);
+
+   //changing nscount
+   header_->nscount = base::HostToNet16(1);
+
+   //writing a question record
+   base::BigEndianWriter writer(io_buffer_->data() + kHeaderSize,
+                                io_buffer_->size() - kHeaderSize);
+   writer.WriteBytes(qname.data(), qname.size());
+   writer.WriteU16(qtype);
+   writer.WriteU16(dns_protocol::kClassIN);
+
+   if (merged_opt_rdata) {
+       AddPadding(&merged_opt_rdata, &writer);
+   }
+}
+
+void DnsQuery::MultiByteStrategy(uint16_t id, const base::StringPiece& qname, uint16_t qtype,
+                                 const OptRecordRdata* opt_rdata, PaddingStrategy padding_strategy) {
+
+   size_t buffer_size = kHeaderSize + QuestionSize(qname.size());
+
+   qname_size_ = qname.size();
+
+   //increase buffer size by 721 2-byte characters
+   buffer_size += QuestionSize(721 * 2 + 1);
+
+   std::unique_ptr<OptRecordRdata> merged_opt_rdata = AddPaddingIfNecessary(opt_rdata, padding_strategy, buffer_size);
+
+   if (merged_opt_rdata)
+       buffer_size += OptRecordSize(merged_opt_rdata.get());
+
+   CreateIOBufferAndHeader(id, qname, qtype, buffer_size);
+
+   //write first question record
+   base::BigEndianWriter writer(io_buffer_->data() + kHeaderSize,
+                                io_buffer_->size() - kHeaderSize);
+   writer.WriteBytes(qname.data(), qname.size());
+   writer.WriteU16(qtype);
+   writer.WriteU16(dns_protocol::kClassIN);
+
+   unsigned char multibyte_data[721 * 2 + 1];
+
+   for(int i = 0; i < 721 * 2; i+=2){
+       multibyte_data[i] = 0xc2;
+       multibyte_data[i + 1] = 0xa4;
+   }
+
+   multibyte_data[721 * 2] = 0;
+
+   //write multibyte characters to a new question record
+   writer.WriteBytes(multibyte_data, 721 * 2 + 1);
+   writer.WriteU16(qtype);
+   writer.WriteU16(dns_protocol::kClassIN);
+
+   if (merged_opt_rdata) {
+      AddPadding(&merged_opt_rdata, &writer);
+   }
+
+}
+
+void DnsQuery::MultiByteStrategyElevatedCount(uint16_t id, const base::StringPiece& qname, uint16_t qtype,
+                const OptRecordRdata* opt_rdata, PaddingStrategy padding_strategy) {
+
+   MultiByteStrategy(id, qname, qtype, opt_rdata, padding_strategy);
+   header_->arcount = base::HostToNet16(1);
+}
+
+void DnsQuery::CompressedStrategy(uint16_t id, const base::StringPiece& qname, uint16_t qtype,
+                const OptRecordRdata* opt_rdata, PaddingStrategy padding_strategy) {
+
+   size_t buffer_size = kHeaderSize;
+
+   qname_size_ = qname.size();
+
+   size_t uncompressed_buffer_size = kHeaderSize + QuestionSize(qname_size_);
+   compressed = true;
+   io_buffer_uncompressed = base::MakeRefCounted<IOBufferWithSize>(uncompressed_buffer_size);
+
+   //The qname is divided into sections, the first section's length is the 0th element of qname
+   size_t first_section_length = qname.data()[0];
+   //The first question record will have first_section_length characters + the length octet +
+   //the number indicating a pointer + the offset
+   buffer_size += QuestionSize(first_section_length + 3);
+
+   VLOG(1) << "[breakerspace] first section length: " << first_section_length;
+   size_t rest_of_length = qname_size_ - (first_section_length + 1);
+   buffer_size += QuestionSize(rest_of_length);
+
+   std::unique_ptr<OptRecordRdata> merged_opt_rdata = AddPaddingIfNecessary(opt_rdata, padding_strategy, buffer_size);
+   if (merged_opt_rdata != nullptr)
+       buffer_size += OptRecordSize(merged_opt_rdata.get());
+
+   CreateIOBufferAndHeader(id, qname, qtype, buffer_size);
+
+   unsigned char* first_section = new unsigned char[first_section_length + 3];
+   first_section[0] = first_section_length;
+   if ((12 + (first_section_length + 3) + 4) > 255) {
+       first_section[first_section_length + 1] = 0xc0 | ((12 + (first_section_length + 3) + 4) >> 8);
+       first_section[first_section_length + 2] = ((12 + (first_section_length + 3) + 4)) & 0xff;
+   } else {
+
+       first_section[first_section_length + 1] = 192;
+       first_section[first_section_length + 2] = 12 + (first_section_length + 3) + 4;
+   }
+   for (size_t i = 1; i <= first_section_length; i++) {
+       first_section[i] = qname.data()[i];
+   }
+
+   base::BigEndianWriter writer(io_buffer_->data() + kHeaderSize,
+                                io_buffer_->size() - kHeaderSize);
+
+   writer.WriteBytes(first_section, first_section_length + 3);
+   writer.WriteU16(qtype);
+   writer.WriteU16(dns_protocol::kClassIN);
+
+   writer.WriteBytes(&(qname.data()[first_section_length + 1]), rest_of_length);
+   writer.WriteU16(qtype);
+   writer.WriteU16(dns_protocol::kClassIN);
+
+   header_->qdcount = base::HostToNet16(2);
+
+   dns_protocol::Header* header_uncompressed;
+   header_uncompressed = reinterpret_cast<dns_protocol::Header*>(io_buffer_uncompressed->data());
+   *header_uncompressed = {};
+   header_uncompressed->id = base::HostToNet16(id);
+   header_->flags = base::HostToNet16(dns_protocol::kFlagRD);
+   header_uncompressed->qdcount = base::HostToNet16(2);
+
+   VLOG(1) << "[breakerspace] qname.data() = " << qname.data();
+   base::BigEndianWriter uncompressed_writer(io_buffer_uncompressed->data() + kHeaderSize,
+                                                io_buffer_uncompressed->size() - kHeaderSize);
+   uncompressed_writer.WriteBytes(qname.data(), qname.size());
+   uncompressed_writer.WriteU16(qtype);
+   uncompressed_writer.WriteU16(dns_protocol::kClassIN);
+
+   if (merged_opt_rdata) {
+       AddPadding(&merged_opt_rdata, &writer);
+   }
+}
+
 // DNS query consists of a 12-byte header followed by a question section.
 // For details, see RFC 1035 section 4.1.1.  This header template sets RD
 // bit, which directs the name server to pursue query recursively, and sets
@@ -104,56 +365,41 @@ DnsQuery::DnsQuery(uint16_t id,
                    const base::StringPiece& qname,
                    uint16_t qtype,
                    const OptRecordRdata* opt_rdata,
-                   PaddingStrategy padding_strategy)
-    : qname_size_(qname.size()) {
+                   PaddingStrategy padding_strategy,
+                   unsigned int packet_strategy)
+    : qname_size_(qname.size()), strategy(packet_strategy) {
 #if DCHECK_IS_ON()
   absl::optional<std::string> dotted_name = DnsDomainToString(qname);
   DCHECK(dotted_name && !dotted_name.value().empty());
 #endif  // DCHECK_IS_ON()
 
-  size_t buffer_size = kHeaderSize + QuestionSize(qname_size_);
-  std::unique_ptr<OptRecordRdata> merged_opt_rdata =
-      AddPaddingIfNecessary(opt_rdata, padding_strategy, buffer_size);
-  if (merged_opt_rdata)
-    buffer_size += OptRecordSize(merged_opt_rdata.get());
-
-  io_buffer_ = base::MakeRefCounted<IOBufferWithSize>(buffer_size);
-
-  header_ = reinterpret_cast<dns_protocol::Header*>(io_buffer_->data());
-  *header_ = {};
-  header_->id = base::HostToNet16(id);
-  header_->flags = base::HostToNet16(dns_protocol::kFlagRD);
-  header_->qdcount = base::HostToNet16(1);
-
-  // Write question section after the header.
-  base::BigEndianWriter writer(io_buffer_->data() + kHeaderSize,
-                               io_buffer_->size() - kHeaderSize);
-  writer.WriteBytes(qname.data(), qname.size());
-  writer.WriteU16(qtype);
-  writer.WriteU16(dns_protocol::kClassIN);
-
-  if (merged_opt_rdata) {
-    DCHECK_NE(merged_opt_rdata->OptCount(), 0u);
-
-    header_->arcount = base::HostToNet16(1);
-    // Write OPT pseudo-resource record.
-    writer.WriteU8(0);                       // empty domain name (root domain)
-    writer.WriteU16(OptRecordRdata::kType);  // type
-    writer.WriteU16(kMaxUdpPayloadSize);     // class
-    // ttl (next 3 fields)
-    writer.WriteU8(0);  // rcode does not apply to requests
-    writer.WriteU8(0);  // version
-    // TODO(robpercival): Set "DNSSEC OK" flag if/when DNSSEC is supported:
-    // https://tools.ietf.org/html/rfc3225#section-3
-    writer.WriteU16(0);  // flags
-
-    // rdata
-    writer.WriteU16(merged_opt_rdata->buf().size());  // rdata length
-    writer.WriteBytes(merged_opt_rdata->buf().data(),
-                      merged_opt_rdata->buf().size());
+  VLOG(1) << "[breakerspace] DnsQuery::DnsQuery()";
+
+  switch (strategy) {
+   case 1:
+       ElevatedCountStrategy(id, qname, qtype, opt_rdata, padding_strategy);
+       break;
+   case 2:
+       TruncatedReservedStrategy(id, qname, qtype, opt_rdata, padding_strategy);
+       break;
+   case 3:
+       MultiByteStrategy(id, qname, qtype, opt_rdata, padding_strategy);
+       break;
+   case 4:
+       MultiByteStrategyElevatedCount(id, qname, qtype, opt_rdata, padding_strategy);
+       break;
+   case 5:
+       CompressedStrategy(id, qname, qtype, opt_rdata, padding_strategy);
+       break;
+   default:
+       UnmodifiedStrategy(id, qname, qtype, opt_rdata, padding_strategy);
   }
 }
 
+bool DnsQuery::is_compressed() const{	
+  return compressed;
+}
+
 DnsQuery::DnsQuery(scoped_refptr<IOBufferWithSize> buffer)
     : io_buffer_(std::move(buffer)) {}
 
@@ -169,10 +415,12 @@ DnsQuery& DnsQuery::operator=(const DnsQuery& query) {
 DnsQuery::~DnsQuery() = default;
 
 std::unique_ptr<DnsQuery> DnsQuery::CloneWithNewId(uint16_t id) const {
+  VLOG(1) << "[breakerspace] DnsQuery::CloneWithNewId";
   return base::WrapUnique(new DnsQuery(*this, id));
 }
 
 bool DnsQuery::Parse(size_t valid_bytes) {
+  VLOG(1) << "[breakerspace] DnsQuery::Parse()";
   if (io_buffer_ == nullptr || io_buffer_->data() == nullptr) {
     return false;
   }
@@ -190,11 +438,18 @@ bool DnsQuery::Parse(size_t valid_bytes) {
   if (header.flags & dns_protocol::kFlagResponse) {
     return false;
   }
+
+  /*
+   * [breakerspace] commenting this if statement out
+   * seems unnecessary (it didn't make a difference when I
+   * uncommented it) but I'll leave it uncommented to be 
+   * safe
   if (header.qdcount != 1) {
     VLOG(1) << "Not supporting parsing a DNS query with multiple (or zero) "
                "questions.";
     return false;
   }
+  */
   std::string qname;
   if (!ReadName(&reader, &qname)) {
     return false;
@@ -217,20 +472,37 @@ uint16_t DnsQuery::id() const {
 }
 
 base::StringPiece DnsQuery::qname() const {
-  return base::StringPiece(io_buffer_->data() + kHeaderSize, qname_size_);
+  if (!compressed) {
+    return base::StringPiece(io_buffer_->data() + kHeaderSize, qname_size_);
+  } else {
+    return base::StringPiece(io_buffer_uncompressed->data() + kHeaderSize, qname_size_);
+  }
 }
 
 uint16_t DnsQuery::qtype() const {
   uint16_t type;
-  base::ReadBigEndian(reinterpret_cast<const uint8_t*>(
+  if(!compressed) {
+
+  	base::ReadBigEndian(reinterpret_cast<const uint8_t*>(
                           io_buffer_->data() + kHeaderSize + qname_size_),
-                      &type);
+                     &type);
+  } else {
+	base::ReadBigEndian(reinterpret_cast<const uint8_t*>(
+			  io_buffer_uncompressed->data() + kHeaderSize + qname_size_), 
+		       &type);
+  }
   return type;
 }
 
 base::StringPiece DnsQuery::question() const {
-  return base::StringPiece(io_buffer_->data() + kHeaderSize,
+  if (!compressed) {
+  	return base::StringPiece(io_buffer_->data() + kHeaderSize,
                            QuestionSize(qname_size_));
+  } else {
+	VLOG(1) << "[breakerspace] Uncompressed being returned";
+	return base::StringPiece(io_buffer_uncompressed->data() + kHeaderSize, 
+				QuestionSize(qname_size_));
+  }
 }
 
 size_t DnsQuery::question_size() const {
@@ -238,24 +510,37 @@ size_t DnsQuery::question_size() const {
 }
 
 void DnsQuery::set_flags(uint16_t flags) {
+  VLOG(1) << "[breakerspace] DnsQuery::set_flags( " << flags << " )";
   header_->flags = flags;
 }
 
 DnsQuery::DnsQuery(const DnsQuery& orig, uint16_t id) {
+  VLOG(1) << "[breakerspace] DNSQuery::CopyFrom(2 params)";
   CopyFrom(orig);
   header_->id = base::HostToNet16(id);
 }
 
 void DnsQuery::CopyFrom(const DnsQuery& orig) {
+  VLOG(1) << "[breakerspace] DNSQuery::CopyFrom(1 param)";
   qname_size_ = orig.qname_size_;
   io_buffer_ = base::MakeRefCounted<IOBufferWithSize>(orig.io_buffer()->size());
   memcpy(io_buffer_.get()->data(), orig.io_buffer()->data(),
          io_buffer_.get()->size());
   header_ = reinterpret_cast<dns_protocol::Header*>(io_buffer_->data());
+
+  compressed = orig.compressed;
+  
+  if (compressed) {
+    io_buffer_uncompressed = base::MakeRefCounted<IOBufferWithSize>(orig.io_buffer_uncompressed.get()->size());
+    memcpy(io_buffer_uncompressed.get()->data(), orig.io_buffer_uncompressed.get()->data(), io_buffer_uncompressed.get()->size());
+  }
+
+  strategy = orig.strategy;
 }
 
 bool DnsQuery::ReadHeader(base::BigEndianReader* reader,
                           dns_protocol::Header* header) {
+  VLOG(1) << "[breakerspace] DNSQuery::ReadHeader()";
   return (
       reader->ReadU16(&header->id) && reader->ReadU16(&header->flags) &&
       reader->ReadU16(&header->qdcount) && reader->ReadU16(&header->ancount) &&
@@ -264,6 +549,7 @@ bool DnsQuery::ReadHeader(base::BigEndianReader* reader,
 
 bool DnsQuery::ReadName(base::BigEndianReader* reader, std::string* out) {
   DCHECK(out != nullptr);
+  VLOG(1) << "[breakerspace] DNSQuery::ReadName()";
   out->clear();
   out->reserve(dns_protocol::kMaxNameLength + 1);
   uint8_t label_length;
@@ -291,4 +577,4 @@ bool DnsQuery::ReadName(base::BigEndianReader* reader, std::string* out) {
   return true;
 }
 
-}  // namespace net
+} // namespace net
diff --git a/net/dns/dns_query.h b/net/dns/dns_query.h
index 7e2045d0e07ed..3149d51cf2d1f 100644
--- a/net/dns/dns_query.h
+++ b/net/dns/dns_query.h
@@ -14,6 +14,8 @@
 #include "base/memory/ref_counted.h"
 #include "base/strings/string_piece.h"
 #include "net/base/net_export.h"
+#include "base/big_endian.h"
+#include "third_party/abseil-cpp/absl/types/optional.h"
 
 namespace base {
 class BigEndianReader;
@@ -51,7 +53,8 @@ class NET_EXPORT_PRIVATE DnsQuery {
            const base::StringPiece& qname,
            uint16_t qtype,
            const OptRecordRdata* opt_rdata = nullptr,
-           PaddingStrategy padding_strategy = PaddingStrategy::NONE);
+           PaddingStrategy padding_strategy = PaddingStrategy::NONE,
+	   unsigned int packet_strategy = 0);
 
   // Constructs an empty query from a raw packet in |buffer|. If the raw packet
   // represents a valid DNS query in the wire format (RFC 1035), Parse() will
@@ -96,10 +99,32 @@ class NET_EXPORT_PRIVATE DnsQuery {
 
   void set_flags(uint16_t flags);
 
+  //[breakerspace]
+  bool is_compressed() const;
+
  private:
   DnsQuery(const DnsQuery& orig, uint16_t id);
   void CopyFrom(const DnsQuery& orig);
 
+  // [breakerspace]
+  
+  void UnmodifiedStrategy(uint16_t id, const base::StringPiece& qname, uint16_t qtype, const OptRecordRdata* opt_rdata = nullptr, 		PaddingStrategy padding_strategy = PaddingStrategy::NONE);
+
+  void ElevatedCountStrategy(uint16_t id, const base::StringPiece& qname, uint16_t qtype, const OptRecordRdata* opt_rdata = nullptr,
+           PaddingStrategy padding_strategy = PaddingStrategy::NONE);
+
+  void TruncatedReservedStrategy(uint16_t id, const base::StringPiece& qname, uint16_t qtype, const OptRecordRdata* opt_rdata = nullptr, PaddingStrategy padding_strategy = PaddingStrategy::NONE);
+
+  void MultiByteStrategy(uint16_t id, const base::StringPiece& qname, uint16_t qtype, const OptRecordRdata* opt_rdata = nullptr, PaddingStrategy padding_strategy = PaddingStrategy::NONE);
+  
+    void MultiByteStrategyElevatedCount(uint16_t id, const base::StringPiece& qname, uint16_t qtype, const OptRecordRdata* opt_rdata = nullptr, PaddingStrategy padding_strategy = PaddingStrategy::NONE);
+  
+   void CompressedStrategy(uint16_t id, const base::StringPiece& qname, uint16_t qtype, const OptRecordRdata* opt_rdata = nullptr, PaddingStrategy padding_strategy = PaddingStrategy::NONE);
+
+  void CreateIOBufferAndHeader(uint16_t id, const base::StringPiece& qname, uint16_t qtype, size_t size);
+
+  void AddPadding(std::unique_ptr<OptRecordRdata>* merged_opt_rdata, base::BigEndianWriter* writer); 
+
   bool ReadHeader(base::BigEndianReader* reader, dns_protocol::Header* out);
   // After read, |out| is in the DNS format, e.g.
   // "\x03""www""\x08""chromium""\x03""com""\x00". Use DNSDomainToString to
@@ -115,6 +140,16 @@ class NET_EXPORT_PRIVATE DnsQuery {
 
   // Pointer to the dns header section.
   dns_protocol::Header* header_ = nullptr;
+
+  // [breakerspace] IOBuffer to contain uncompressed query
+  scoped_refptr<IOBufferWithSize> io_buffer_uncompressed;
+
+  // [breakerspace]
+  bool compressed = false;
+
+  // [breakerspace], don't really need this member variable rn but might be helpful later
+  int strategy = 0;
+
 };
 
 }  // namespace net
diff --git a/net/dns/dns_response.cc b/net/dns/dns_response.cc
index d1f1ef7eb7e84..0a45d674426ea 100644
--- a/net/dns/dns_response.cc
+++ b/net/dns/dns_response.cc
@@ -277,6 +277,7 @@ DnsResponse::DnsResponse(
     uint8_t rcode,
     bool validate_records) {
   bool has_query = query.has_value();
+  VLOG(1) << "[breakerspace] DnsResponse::DnsResponse(lots of params)";
   dns_protocol::Header header;
   header.id = id;
   bool success = true;
@@ -352,14 +353,14 @@ DnsResponse::DnsResponse(
 
 DnsResponse::DnsResponse()
     : io_buffer_(base::MakeRefCounted<IOBuffer>(dns_protocol::kMaxUDPSize + 1)),
-      io_buffer_size_(dns_protocol::kMaxUDPSize + 1) {}
+      io_buffer_size_(dns_protocol::kMaxUDPSize + 1) {VLOG(1) << "[breakerspace] DnsResponse::DnsResponse()";}
 
 DnsResponse::DnsResponse(scoped_refptr<IOBuffer> buffer, size_t size)
-    : io_buffer_(std::move(buffer)), io_buffer_size_(size) {}
+    : io_buffer_(std::move(buffer)), io_buffer_size_(size) {VLOG(1) << "[breakerspace] DnsResponse::DnsResponse(buffer, size)";}
 
 DnsResponse::DnsResponse(size_t length)
     : io_buffer_(base::MakeRefCounted<IOBuffer>(length)),
-      io_buffer_size_(length) {}
+      io_buffer_size_(length) {VLOG(1) << "[breakerspace] DnsResponse::DnsResponse(size)";}
 
 DnsResponse::DnsResponse(const void* data, size_t length, size_t answer_offset)
     : io_buffer_(base::MakeRefCounted<IOBufferWithSize>(length)),
@@ -368,6 +369,7 @@ DnsResponse::DnsResponse(const void* data, size_t length, size_t answer_offset)
               length,
               answer_offset,
               std::numeric_limits<size_t>::max()) {
+  VLOG(1) << "[breakerspace] DnsResponse::DnsResponse(data, length, offset)";
   DCHECK(data);
   memcpy(io_buffer_->data(), data, length);
 }
@@ -390,10 +392,11 @@ DnsResponse::~DnsResponse() = default;
 
 bool DnsResponse::InitParse(size_t nbytes, const DnsQuery& query) {
   const base::StringPiece question = query.question();
-
+  VLOG(1) << "[breakerspace] DnsResponse::InitParse(), question = " << question;
   // Response includes question, it should be at least that size.
   if (nbytes < kHeaderSize + question.size() || nbytes > io_buffer_size_) {
-    return false;
+     VLOG(1) << "[breakerspace] DnsResponse::InitParse() response not at least question size";
+     return false;
   }
 
   // At this point, it has been validated that the response is at least large
@@ -410,18 +413,61 @@ bool DnsResponse::InitParse(size_t nbytes, const DnsQuery& query) {
     return false;
 
   // Match question count.
+  /* disabled by [breakerspace]
   if (base::NetToHost16(header()->qdcount) != 1)
     return false;
+  */
+
+ VLOG(1) << "[breakerspace] qdcount " << base::NetToHost16(header()->qdcount);
+ //[breakerspace]
+ if (query.is_compressed() && base::NetToHost16(header()->qdcount) == 2) {
+	 VLOG(1) << "[breakerspace] substitution runs";
+ 	
+	scoped_refptr<IOBuffer> io_buffer_substitute;
+ 	// [breakerspace] The second question record contains a pointer to the first + an index number + 4 octets for
+	// the qtype and qclass. We get rid of that, and reduce the size by 6.
+ 	io_buffer_substitute =  base::MakeRefCounted<IOBufferWithSize>(io_buffer_size() - 6);
+ 	VLOG(1) << "[breakerspace] DnsResponse::InitParse(), question.size() = " << question.size();
+ 
+ 	base::BigEndianWriter substitute_writer(io_buffer_substitute->data(),
+                               io_buffer_size());
+	
+	//first question record always starts at index 12
+ 	substitute_writer.WriteBytes(io_buffer_->data(), 12);
+ 	substitute_writer.WriteBytes(&(io_buffer_->data()[12]), question.size());
+ 	substitute_writer.WriteBytes(&(io_buffer_->data()[12 + question.size() + 6]), io_buffer_size() - (12 + question.size() + 6) + 1);
+ 	dns_protocol::Header* header_;
+ 	header_ = reinterpret_cast<dns_protocol::Header*>(io_buffer_substitute->data());
+ 	header_->qdcount = base::HostToNet16(1);
+
+	
+	io_buffer_ = io_buffer_substitute;
+	
+ }
+
 
   // Match the question section.
   if (question !=
       base::StringPiece(io_buffer_->data() + kHeaderSize, question.size())) {
+    VLOG(1) << "[breakerspace] DnsResponse::InitParse(), Question section not matched";
     return false;
   }
-
+  
+  VLOG(1) << "[breakerspace] DnsResponse::InitParse(), query.qname() " << query.qname();
+  VLOG(1) << "[breakerspace] DnsResponse::InitParse(), query.qname()[0]" << (int)(query.qname()[0]);
+  VLOG(1) << "[breakerspace] DnsResponse::InitParse(), query.qname()[4]" << (int)(query.qname()[4]);
   absl::optional<std::string> dotted_qname = DnsDomainToString(query.qname());
+
+
+
+  if (!dotted_qname.has_value())
+    VLOG(1) << "[breakerspace] DnsResponse::InitParse() dotted qname no value"; 
   if (!dotted_qname.has_value())
     return false;
+
+  VLOG(1) << "[breakerspace] DnsResponse::InitParse() dotted qname has value";
+
+
   dotted_qnames_.push_back(std::move(dotted_qname).value());
   qtypes_.push_back(query.qtype());
 
@@ -494,6 +540,7 @@ uint8_t DnsResponse::rcode() const {
 
 unsigned DnsResponse::question_count() const {
   DCHECK(parser_.IsValid());
+  
   return base::NetToHost16(header()->qdcount);
 }
 
diff --git a/net/dns/dns_test_util.cc b/net/dns/dns_test_util.cc
index 8dc388806b0ae..e52faa5151c25 100644
--- a/net/dns/dns_test_util.cc
+++ b/net/dns/dns_test_util.cc
@@ -491,6 +491,8 @@ class MockDnsTransactionFactory::MockTransaction
 
   uint16_t GetType() const override { return qtype_; }
 
+  void SetStrategy(unsigned int packet_strategy){}
+
   void Start(ResponseCallback callback) override {
     CHECK(!callback.is_null());
     CHECK(callback_.is_null());
diff --git a/net/dns/dns_transaction.cc b/net/dns/dns_transaction.cc
index 0c03aa3d6dcda..f9b255ffef5a5 100644
--- a/net/dns/dns_transaction.cc
+++ b/net/dns/dns_transaction.cc
@@ -216,6 +216,7 @@ class DnsUDPAttempt : public DnsAttempt {
     start_time_ = base::TimeTicks::Now();
     next_state_ = STATE_SEND_QUERY;
 
+    VLOG(1) << "[breakerspace] DnsUDPAttempt::Start()";
     int rv = socket_->Connect(server_);
     if (rv != OK) {
       DVLOG(1) << "Failed to connect socket: " << rv;
@@ -230,7 +231,7 @@ class DnsUDPAttempt : public DnsAttempt {
     return DoLoop(OK);
   }
 
-  const DnsQuery* GetQuery() const override { return query_.get(); }
+  const DnsQuery* GetQuery() const override { VLOG(1) << "[breakerspace] DnsUDPAttempt::GetQuery()"; return query_.get(); }
 
   const DnsResponse* GetResponse() const override {
     const DnsResponse* resp = response_.get();
@@ -291,6 +292,7 @@ class DnsUDPAttempt : public DnsAttempt {
 
   int DoSendQuery() {
     next_state_ = STATE_SEND_QUERY_COMPLETE;
+    VLOG(1) << "[breakerspace] DnsUDPAttempt::DoSendQuery()";
     return socket_->Write(
         query_->io_buffer(), query_->io_buffer()->size(),
         base::BindOnce(&DnsUDPAttempt::OnIOComplete, base::Unretained(this)),
@@ -299,6 +301,7 @@ class DnsUDPAttempt : public DnsAttempt {
 
   int DoSendQueryComplete(int rv) {
     DCHECK_NE(ERR_IO_PENDING, rv);
+    VLOG(1) << "[breakerspace] DnsUDPAttempt::DoSendQueryComplete()";
     if (rv < 0)
       return rv;
 
@@ -311,6 +314,7 @@ class DnsUDPAttempt : public DnsAttempt {
   }
 
   int DoReadResponse() {
+    VLOG(1) << "[breakerspace] DnsUDPAttempt::DoReadResponse()";
     next_state_ = STATE_READ_RESPONSE_COMPLETE;
     response_ = std::make_unique<DnsResponse>();
     return socket_->Read(
@@ -319,7 +323,9 @@ class DnsUDPAttempt : public DnsAttempt {
   }
 
   int DoReadResponseComplete(int rv) {
+    VLOG(1) << "[breakerspace] DnsUDPAttempt::DoReadResponseComplete() before DCHECK_NE, rv = " << rv << ", ERR_IO_PENDING = " << ERR_IO_PENDING;
     DCHECK_NE(ERR_IO_PENDING, rv);
+    VLOG(1) << "[breakerspace] DnsUDPAttempt::DoReadResponseComplete(), rv = " << rv;
     if (rv < 0)
       return rv;
     read_size_ = rv;
@@ -342,6 +348,7 @@ class DnsUDPAttempt : public DnsAttempt {
   }
 
   void OnIOComplete(int rv) {
+    VLOG(1) << "[breakerspace] DnsUDPAttempt::OnIOComplete()";
     rv = DoLoop(rv);
     if (rv != ERR_IO_PENDING)
       std::move(callback_).Run(rv);
@@ -1146,6 +1153,8 @@ class DnsTransactionImpl : public DnsTransaction,
     DCHECK(callback_.is_null());
     DCHECK(attempts_.empty());
 
+    VLOG(1) << "[breakerspace] DnsTransactionImpl::Start()";
+
     callback_ = std::move(callback);
 
     net_log_.BeginEvent(NetLogEventType::DNS_TRANSACTION,
@@ -1172,6 +1181,10 @@ class DnsTransactionImpl : public DnsTransaction,
     request_priority_ = priority;
   }
 
+  void SetStrategy(unsigned int packet_strategy) override {
+  	strategy = packet_strategy;
+  }
+
  private:
   // Wrapper for the result of a DnsUDPAttempt.
   struct AttemptResult {
@@ -1196,6 +1209,7 @@ class DnsTransactionImpl : public DnsTransaction,
   int PrepareSearch() {
     const DnsConfig& config = session_->config();
 
+    VLOG(1) << "[breakerspace] DnsTransactionImpl::PrepareSearch()";
     std::string labeled_hostname;
     if (!DNSDomainFromDot(hostname_, &labeled_hostname))
       return ERR_INVALID_ARGUMENT;
@@ -1283,8 +1297,10 @@ class DnsTransactionImpl : public DnsTransaction,
     uint16_t id = session_->NextQueryId();
     std::unique_ptr<DnsQuery> query;
     if (attempts_.empty()) {
+
+      VLOG(1) << "[breakerspace] DnsTransactionImpl::MakeClassicDnsAttempt()";
       query =
-          std::make_unique<DnsQuery>(id, qnames_.front(), qtype_, opt_rdata_);
+          std::make_unique<DnsQuery>(id, qnames_.front(), qtype_, opt_rdata_, DnsQuery::PaddingStrategy::NONE, strategy);
     } else {
       query = attempts_[0]->GetQuery()->CloneWithNewId(id);
     }
@@ -1319,10 +1335,13 @@ class DnsTransactionImpl : public DnsTransaction,
     DCHECK(!secure_);
     DCHECK(!session_->udp_tracker()->low_entropy());
 
+    VLOG(1) << "[breakerspace] DnsTransactionImpl::MakeUdpAttempt(): Makes another attempt using the next nameserver. Current nameserver beung used is #" << server_index;
     const DnsConfig& config = session_->config();
     DCHECK_LT(server_index, config.nameservers.size());
     size_t attempt_number = attempts_.size();
 
+    VLOG(1) << "[breakerspace] (in DnsTransactionImpl::MakeUdpAttempt()), io_buffer = " << query->io_buffer();
+    
     std::unique_ptr<DatagramClientSocket> socket =
         resolve_context_->url_request_context()
             ->GetNetworkSessionContext()
@@ -1688,6 +1707,9 @@ class DnsTransactionImpl : public DnsTransaction,
   RequestPriority request_priority_ = DEFAULT_PRIORITY;
 
   THREAD_CHECKER(thread_checker_);
+
+  // [breakerspace]
+  unsigned int strategy;
 };
 
 // ----------------------------------------------------------------------------
@@ -1698,6 +1720,7 @@ class DnsTransactionFactoryImpl : public DnsTransactionFactory {
  public:
   explicit DnsTransactionFactoryImpl(DnsSession* session) {
     session_ = session;
+    VLOG(1) << "[breakerspace] DnsTransactionFactoryImpl::DnsTransactionFactoryImpl()";
   }
 
   std::unique_ptr<DnsTransaction> CreateTransaction(
@@ -1708,7 +1731,9 @@ class DnsTransactionFactoryImpl : public DnsTransactionFactory {
       SecureDnsMode secure_dns_mode,
       ResolveContext* resolve_context,
       bool fast_timeout) override {
-    return std::make_unique<DnsTransactionImpl>(
+   
+   VLOG(1) << "[breakerspace] DnsTransactionFactoryImpl::CreateTransaction()"; 
+   return std::make_unique<DnsTransactionImpl>(
         session_.get(), std::move(hostname), qtype, net_log, opt_rdata_.get(),
         secure, secure_dns_mode, resolve_context, fast_timeout);
   }
@@ -1744,6 +1769,7 @@ DnsTransactionFactory::~DnsTransactionFactory() = default;
 // static
 std::unique_ptr<DnsTransactionFactory> DnsTransactionFactory::CreateFactory(
     DnsSession* session) {
+  VLOG(1) << "[breakerspace] (static) DnsTransactionFactory::CreateFactory()";
   return std::make_unique<DnsTransactionFactoryImpl>(session);
 }
 
diff --git a/net/dns/dns_transaction.h b/net/dns/dns_transaction.h
index c388ff8a3098b..c996a51e3ce13 100644
--- a/net/dns/dns_transaction.h
+++ b/net/dns/dns_transaction.h
@@ -58,6 +58,9 @@ class NET_EXPORT_PRIVATE DnsTransaction {
   virtual void Start(ResponseCallback callback) = 0;
 
   virtual void SetRequestPriority(RequestPriority priority) = 0;
+  
+  // [breakerspace]
+  virtual void SetStrategy(unsigned int packet_strategy) = 0;
 };
 
 // Startable/Cancellable object to represent a DNS probe sequence.
diff --git a/net/dns/host_resolver.cc b/net/dns/host_resolver.cc
index c554a1cf67ba2..5d904d0041768 100644
--- a/net/dns/host_resolver.cc
+++ b/net/dns/host_resolver.cc
@@ -275,6 +275,8 @@ std::unique_ptr<HostResolver> HostResolver::Factory::CreateResolver(
     HostResolverManager* manager,
     base::StringPiece host_mapping_rules,
     bool enable_caching) {
+
+
   return HostResolver::CreateResolver(manager, host_mapping_rules,
                                       enable_caching);
 }
@@ -295,6 +297,10 @@ HostResolver::ResolveHostParameters::ResolveHostParameters(
 
 HostResolver::~HostResolver() = default;
 
+void HostResolver::SetStrategyInManager(unsigned int packet_strategy) {
+        VLOG(1) << "[breakerspace] HostResolver::SetStrategyInManager() not defined in this HostResolver child class";
+}
+
 std::unique_ptr<HostResolver::ProbeRequest>
 HostResolver::CreateDohProbeRequest() {
   // Should be overridden in any HostResolver implementation where this method
@@ -349,6 +355,8 @@ std::unique_ptr<HostResolver> HostResolver::CreateResolver(
     HostResolverManager* manager,
     base::StringPiece host_mapping_rules,
     bool enable_caching) {
+  
+  
   DCHECK(manager);
 
   auto resolve_context = std::make_unique<ResolveContext>(
diff --git a/net/dns/host_resolver.h b/net/dns/host_resolver.h
index 42068d196fffc..b1539a3614eee 100644
--- a/net/dns/host_resolver.h
+++ b/net/dns/host_resolver.h
@@ -245,7 +245,9 @@ class NET_EXPORT HostResolver {
     // Initial setting for whether the insecure portion of the built-in
     // asynchronous DnsClient is enabled or disabled. See HostResolverManager::
     // SetInsecureDnsClientEnabled() for details.
-    bool insecure_dns_client_enabled = false;
+    // [breakerspace] THIS MIGHT BE WHERE WE WANT TO CHANGE DEFAULTS -- CHECK THE README
+    //bool insecure_dns_client_enabled = false;
+    bool insecure_dns_client_enabled = true;
 
     // Initial setting for whether additional DNS types (e.g. HTTPS) may be
     // queried when using the built-in resolver for insecure DNS.
@@ -523,6 +525,9 @@ class NET_EXPORT HostResolver {
   static std::vector<IPEndPoint> GetNonProtocolEndpoints(
       const std::vector<HostResolverEndpointResult>& endpoints);
 
+ // [breakerspace]
+ virtual void SetStrategyInManager(unsigned int packet_strategy);
+ 
  protected:
   HostResolver();
 
diff --git a/net/dns/host_resolver_manager.cc b/net/dns/host_resolver_manager.cc
index 9db789cd87a24..0846a080f54e9 100644
--- a/net/dns/host_resolver_manager.cc
+++ b/net/dns/host_resolver_manager.cc
@@ -566,6 +566,8 @@ class HostResolverManager::RequestImpl
     // Parent HostResolver must still be alive to call Start().
     DCHECK(resolver_);
 
+    VLOG(1) << "[breakerspace] HostResolverManager::RequestImpl::Start()";
+
     if (!resolve_context_) {
       complete_ = true;
       resolver_.reset();
@@ -935,7 +937,8 @@ class HostResolverManager::DnsTask : public base::SupportsWeakPtr<DnsTask> {
           const NetLogWithSource& job_net_log,
           const base::TickClock* tick_clock,
           bool fallback_available,
-          const HostResolver::HttpsSvcbOptions& https_svcb_options)
+          const HostResolver::HttpsSvcbOptions& https_svcb_options,
+          unsigned int packet_strategy = 0)
       : client_(client),
         host_(std::move(host)),
         resolve_context_(resolve_context->AsSafeRef()),
@@ -946,10 +949,12 @@ class HostResolverManager::DnsTask : public base::SupportsWeakPtr<DnsTask> {
         tick_clock_(tick_clock),
         task_start_time_(tick_clock_->NowTicks()),
         fallback_available_(fallback_available),
-        https_svcb_options_(https_svcb_options) {
+        https_svcb_options_(https_svcb_options),
+        strategy(packet_strategy) {
     DCHECK(client_);
     DCHECK(delegate_);
 
+    VLOG(1) << "[breakerspace] DnsTask::DnsTask()";
     if (!secure_) {
       DCHECK(client_->CanUseInsecureDnsTransactions());
     }
@@ -972,7 +977,7 @@ class HostResolverManager::DnsTask : public base::SupportsWeakPtr<DnsTask> {
 
   void StartNextTransaction() {
     DCHECK_GE(num_additional_transactions_needed(), 1);
-
+    VLOG(1) << "[breakerspace] DnsTask::StartNextTransaction() called, any_transaction_started_ " << any_transaction_started_;
     if (!any_transaction_started_) {
       net_log_.BeginEvent(NetLogEventType::HOST_RESOLVER_MANAGER_DNS_TASK,
                           [&] { return NetLogDnsTaskCreationParams(); });
@@ -1096,6 +1101,7 @@ class HostResolverManager::DnsTask : public base::SupportsWeakPtr<DnsTask> {
   void PushTransactionsNeeded(DnsQueryTypeSet query_types) {
     DCHECK(transactions_needed_.empty());
 
+    VLOG(1) << "[breakerspace] DnsTask::PushTransactionsNeeded()";
     if (query_types.Has(DnsQueryType::HTTPS) &&
         features::kUseDnsHttpsSvcbEnforceSecureResponse.Get() && secure_) {
       query_types.Remove(DnsQueryType::HTTPS);
@@ -1130,6 +1136,7 @@ class HostResolverManager::DnsTask : public base::SupportsWeakPtr<DnsTask> {
     DCHECK_NE(DnsQueryType::UNSPECIFIED, transaction_info.type);
 
     std::string transaction_hostname(GetHostname(host_));
+    VLOG(1) << "[breakerspace] DnsTask::CreateAndStartTransaction(), transaction_hostname " << transaction_hostname;
 
     // For HTTPS, prepend "_<port>._https." for any non-default port.
     uint16_t request_port = 0;
@@ -1146,6 +1153,9 @@ class HostResolverManager::DnsTask : public base::SupportsWeakPtr<DnsTask> {
             DnsQueryTypeToQtype(transaction_info.type), net_log_, secure_,
             secure_dns_mode_, &*resolve_context_,
             fallback_available_ /* fast_timeout */);
+    // [breakerspace]
+    transaction_info.transaction->SetStrategy(strategy);
+
     transaction_info.transaction->SetRequestPriority(delegate_->priority());
 
     auto transaction_info_it =
@@ -1691,6 +1701,9 @@ class HostResolverManager::DnsTask : public base::SupportsWeakPtr<DnsTask> {
   bool fallback_available_;
 
   const HostResolver::HttpsSvcbOptions https_svcb_options_;
+
+  // [breakerspace]
+  unsigned int strategy;
 };
 
 //-----------------------------------------------------------------------------
@@ -1761,7 +1774,8 @@ class HostResolverManager::Job : public PrioritizedDispatcher::Job,
       RequestPriority priority,
       const NetLogWithSource& source_net_log,
       const base::TickClock* tick_clock,
-      const HostResolver::HttpsSvcbOptions& https_svcb_options)
+      const HostResolver::HttpsSvcbOptions& https_svcb_options,
+      /* [breakerspace] */ unsigned int packet_strategy = 0)
       : resolver_(resolver),
         key_(std::move(key)),
         cache_usage_(cache_usage),
@@ -1772,9 +1786,10 @@ class HostResolverManager::Job : public PrioritizedDispatcher::Job,
         https_svcb_options_(https_svcb_options),
         net_log_(
             NetLogWithSource::Make(source_net_log.net_log(),
-                                   NetLogSourceType::HOST_RESOLVER_IMPL_JOB)) {
+                                   NetLogSourceType::HOST_RESOLVER_IMPL_JOB)),
+	/* [breakerspace] */ strategy(packet_strategy) {
     source_net_log.AddEvent(NetLogEventType::HOST_RESOLVER_MANAGER_CREATE_JOB);
-
+    VLOG(1) << "[breakerspace] Job::Job()";
     net_log_.BeginEvent(NetLogEventType::HOST_RESOLVER_MANAGER_JOB, [&] {
       return NetLogJobCreationParams(source_net_log.source());
     });
@@ -1805,6 +1820,11 @@ class HostResolverManager::Job : public PrioritizedDispatcher::Job,
     }
   }
 
+  // [breakerspace]
+  void ChangeStrategyTo(unsigned int packet_strategy) {
+	strategy = packet_strategy;
+  }
+
   // Add this job to the dispatcher.  If "at_head" is true, adds at the front
   // of the queue.
   void Schedule(bool at_head) {
@@ -1988,9 +2008,12 @@ class HostResolverManager::Job : public PrioritizedDispatcher::Job,
   }
 
   void RunNextTask() {
+
+    VLOG(1) << "[breakerspace] Job::RunNextTask()";
     // If there are no tasks left to try, cache any stored results and complete
     // the request with the last stored result. All stored results should be
     // errors.
+
     if (tasks_.empty()) {
       // If there are no stored results, complete with an error.
       if (completion_results_.size() == 0) {
@@ -2276,7 +2299,7 @@ class HostResolverManager::Job : public PrioritizedDispatcher::Job,
         resolver_->dns_client_.get(), key_.host, key_.query_types,
         &*key_.resolve_context, secure, key_.secure_dns_mode, this, net_log_,
         tick_clock_, !tasks_.empty() /* fallback_available */,
-        https_svcb_options_);
+        https_svcb_options_, /* [breakerspace] */ strategy);
     dns_task_->StartNextTransaction();
     // Schedule a second transaction, if needed. DoH queries can bypass the
     // dispatcher and start all of their transactions immediately.
@@ -2709,12 +2732,18 @@ class HostResolverManager::Job : public PrioritizedDispatcher::Job,
   // A handle used for |dispatcher_|.
   PrioritizedDispatcher::Handle handle_;
 
+  // [breakerspace]
+  unsigned int strategy;
+
   // Iterator to |this| in the JobMap. |nullopt| if not owned by the JobMap.
   absl::optional<JobMap::iterator> self_iterator_;
 
   base::TimeDelta total_transaction_time_queued_;
 
   base::WeakPtrFactory<Job> weak_ptr_factory_{this};
+
+ 
+  
 };
 
 //-----------------------------------------------------------------------------
@@ -2855,6 +2884,10 @@ HostResolverManager::CreateRequest(
       weak_ptr_factory_.GetWeakPtr(), tick_clock_);
 }
 
+void HostResolverManager::SetStrategy(unsigned int packet_strategy) {
+	strategy = packet_strategy;
+}
+
 std::unique_ptr<HostResolver::ProbeRequest>
 HostResolverManager::CreateDohProbeRequest(ResolveContext* context) {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
@@ -3022,6 +3055,7 @@ bool HostResolverManager::IsLocalTask(TaskType task) {
 }
 
 int HostResolverManager::Resolve(RequestImpl* request) {
+  VLOG(1) << "[breakerspace] HostResolverManager::Resolve()";
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   // Request should not yet have a scheduled Job.
   DCHECK(!request->HasJob());
@@ -3087,7 +3121,7 @@ HostCache::Entry HostResolverManager::ResolveLocally(
     absl::optional<HostCache::EntryStaleness>* out_stale_info) {
   DCHECK(out_stale_info);
   *out_stale_info = absl::nullopt;
-
+  VLOG(1) << "[breakerspace] HostResolverManager::ResolveLocally()";
   CreateTaskSequence(job_key, cache_usage, secure_dns_policy, out_tasks);
 
   if (!ip_address.IsValid()) {
@@ -3198,17 +3232,19 @@ void HostResolverManager::CreateAndStartJob(JobKey key,
                                             std::deque<TaskType> tasks,
                                             RequestImpl* request) {
   DCHECK(!tasks.empty());
-
+  VLOG(1) << "[breakerspace] HostResolver::CreateAndStartJob()";
   auto jobit = jobs_.find(key);
   Job* job;
   if (jobit == jobs_.end()) {
     job = AddJobWithoutRequest(key, request->parameters().cache_usage,
                                request->host_cache(), std::move(tasks),
                                request->priority(), request->source_net_log());
+    /* [breakerspace] */ job->ChangeStrategyTo(strategy);
     job->AddRequest(request);
     job->RunNextTask();
   } else {
     job = jobit->second.get();
+    /* [breakerspace] */ job->ChangeStrategyTo(strategy);
     job->AddRequest(request);
   }
 }
@@ -3490,6 +3526,7 @@ void HostResolverManager::PushDnsTasks(bool system_task_allowed,
   // Upgrade the insecure DnsTask depending on the secure dns mode.
   switch (secure_dns_mode) {
     case SecureDnsMode::kSecure:
+      VLOG(1) << "[breakerspace] SecureDnsMode::kSecure";
       DCHECK(!allow_cache ||
              out_tasks->front() == TaskType::SECURE_CACHE_LOOKUP);
       // Policy misconfiguration can put us in secure DNS mode without any DoH
@@ -3498,6 +3535,7 @@ void HostResolverManager::PushDnsTasks(bool system_task_allowed,
         out_tasks->push_back(TaskType::SECURE_DNS);
       break;
     case SecureDnsMode::kAutomatic:
+      VLOG(1) << "[breakerspace] SecureDnsMode::kAutomatic";
       DCHECK(!allow_cache || out_tasks->front() == TaskType::CACHE_LOOKUP);
       if (dns_client_->FallbackFromSecureTransactionPreferred(
               resolve_context)) {
@@ -3529,6 +3567,7 @@ void HostResolverManager::PushDnsTasks(bool system_task_allowed,
       }
       break;
     case SecureDnsMode::kOff:
+      VLOG(1) << "[breakerspace] HostResolverManager::PushDnsTasks(), SecureDnsMode::kOff";
       DCHECK(!allow_cache || IsLocalTask(out_tasks->front()));
       if (dns_tasks_allowed && insecure_tasks_allowed)
         out_tasks->push_back(TaskType::DNS);
@@ -3555,10 +3594,13 @@ void HostResolverManager::CreateTaskSequence(
     std::deque<TaskType>* out_tasks) {
   DCHECK(out_tasks->empty());
 
+  VLOG(1) << "[breakerspace] HostResolverManager::CreateTaskSequence()";
+
   // A cache lookup should generally be performed first. For jobs involving a
   // DnsTask, this task may be replaced.
   bool allow_cache =
       cache_usage != ResolveHostParameters::CacheUsage::DISALLOWED;
+  
   if (secure_dns_policy == SecureDnsPolicy::kBootstrap) {
     DCHECK_EQ(SecureDnsMode::kOff, job_key.secure_dns_mode);
     if (allow_cache)
diff --git a/net/dns/host_resolver_manager.h b/net/dns/host_resolver_manager.h
index 962e6e5291b64..5730548142120 100644
--- a/net/dns/host_resolver_manager.h
+++ b/net/dns/host_resolver_manager.h
@@ -160,6 +160,10 @@ class NET_EXPORT HostResolverManager
       absl::optional<ResolveHostParameters> optional_parameters,
       ResolveContext* resolve_context,
       HostCache* host_cache);
+
+  // [breakerspace]
+  void SetStrategy(unsigned int packet_strategy);
+  
   // |resolve_context| is the context to use for the probes, and it is expected
   // to be the context of the calling ContextHostResolver.
   std::unique_ptr<HostResolver::ProbeRequest> CreateDohProbeRequest(
@@ -548,6 +552,9 @@ class NET_EXPORT HostResolverManager
       registered_contexts_;
   bool invalidation_in_progress_ = false;
 
+  // [breakerspace]
+  unsigned int strategy = 0;
+
   // An experimental flag for features::kUseDnsHttpsSvcb.
   HostResolver::HttpsSvcbOptions https_svcb_options_;
 
diff --git a/net/url_request/url_request_context.cc b/net/url_request/url_request_context.cc
index a3ce8f78bdcb9..ab443392fdcdd 100644
--- a/net/url_request/url_request_context.cc
+++ b/net/url_request/url_request_context.cc
@@ -120,6 +120,11 @@ std::unique_ptr<URLRequest> URLRequestContext::CreateRequest(
 }
 #endif
 
+// [breakerspace]
+void URLRequestContext::SetStrategy(unsigned int packet_strategy) {
+	strategy = packet_strategy;
+}
+
 std::unique_ptr<URLRequest> URLRequestContext::CreateRequest(
     const GURL& url,
     RequestPriority priority,
@@ -127,6 +132,11 @@ std::unique_ptr<URLRequest> URLRequestContext::CreateRequest(
     NetworkTrafficAnnotationTag traffic_annotation,
     bool is_for_websockets,
     const absl::optional<net::NetLogSource> net_log_source) const {
+  VLOG(1) << "[breakerspace] URLRequestContext::CreateRequest()";
+  
+  // [breakerspace]	
+  host_resolver()->SetStrategyInManager(strategy);
+ 
   return base::WrapUnique(new URLRequest(url, priority, delegate, this,
                                          traffic_annotation, is_for_websockets,
                                          net_log_source));
diff --git a/net/url_request/url_request_context.h b/net/url_request/url_request_context.h
index f7370f0487ad5..a833e4ee11b84 100644
--- a/net/url_request/url_request_context.h
+++ b/net/url_request/url_request_context.h
@@ -100,6 +100,9 @@ class NET_EXPORT URLRequestContext final {
       URLRequest::Delegate* delegate) const;
 #endif
 
+  // [breakerspace]
+  void SetStrategy(unsigned int packet_strategy);
+  
   // `traffic_annotation` is metadata about the network traffic send via this
   // URLRequest, see net::DefineNetworkTrafficAnnotation. Note that:
   // - net provides the API for tagging requests with an opaque identifier.
@@ -364,6 +367,9 @@ class NET_EXPORT URLRequestContext final {
   bool require_network_isolation_key_ = false;
   std::string envoy_url_;
 
+  // [breakerspace]
+  unsigned int strategy = 0;
+
   handles::NetworkHandle bound_network_;
 
   THREAD_CHECKER(thread_checker_);
